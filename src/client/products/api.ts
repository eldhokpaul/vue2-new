/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Brand
 */
export interface Brand {
    /**
     * 
     * @type {number}
     * @memberof Brand
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Brand
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Brand
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof Brand
     */
    accountId?: number;
}
/**
 * 
 * @export
 * @interface BrandDto
 */
export interface BrandDto {
    /**
     * 
     * @type {number}
     * @memberof BrandDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof BrandDto
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof BrandDto
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof BrandDto
     */
    accountId?: number;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {any}
     * @memberof InlineObject
     */
    file?: any;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {any}
     * @memberof InlineObject1
     */
    file?: any;
}
/**
 * 
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * 
     * @type {number}
     * @memberof NotificationDto
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationDto
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationDto
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    notificationStatus?: NotificationDtoNotificationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    notificationType?: NotificationDtoNotificationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    notificationSource?: NotificationDtoNotificationSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    entityType?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    messageDateTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationDtoNotificationStatusEnum {
    Unread = 'UNREAD',
    Read = 'READ',
    Dismissed = 'DISMISSED'
}
/**
    * @export
    * @enum {string}
    */
export enum NotificationDtoNotificationTypeEnum {
    Info = 'INFO',
    ActionNeeded = 'ACTION_NEEDED',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum NotificationDtoNotificationSourceEnum {
    GatewayService = 'GATEWAY_SERVICE',
    InvoiceService = 'INVOICE_SERVICE',
    NotificationService = 'NOTIFICATION_SERVICE',
    ProductService = 'PRODUCT_SERVICE',
    ReportingService = 'REPORTING_SERVICE',
    SchedulerService = 'SCHEDULER_SERVICE',
    SupplierService = 'SUPPLIER_SERVICE',
    ShopifyService = 'SHOPIFY_SERVICE',
    AmazonService = 'AMAZON_SERVICE',
    UserService = 'USER_SERVICE',
    XeroService = 'XERO_SERVICE',
    OrdersService = 'ORDERS_SERVICE'
}

/**
 * 
 * @export
 * @interface PageBrand
 */
export interface PageBrand {
    /**
     * 
     * @type {number}
     * @memberof PageBrand
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageBrand
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageBrand
     */
    size?: number;
    /**
     * 
     * @type {Array<Brand>}
     * @memberof PageBrand
     */
    content?: Array<Brand>;
    /**
     * 
     * @type {number}
     * @memberof PageBrand
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageBrand
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageBrand
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageBrand
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageBrand
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageBrand
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageBrand
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageProduct
 */
export interface PageProduct {
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    size?: number;
    /**
     * 
     * @type {Array<Product>}
     * @memberof PageProduct
     */
    content?: Array<Product>;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageProduct
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageProduct
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageProduct
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProduct
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProduct
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageProductChangeLog
 */
export interface PageProductChangeLog {
    /**
     * 
     * @type {number}
     * @memberof PageProductChangeLog
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProductChangeLog
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProductChangeLog
     */
    size?: number;
    /**
     * 
     * @type {Array<ProductChangeLog>}
     * @memberof PageProductChangeLog
     */
    content?: Array<ProductChangeLog>;
    /**
     * 
     * @type {number}
     * @memberof PageProductChangeLog
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageProductChangeLog
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageProductChangeLog
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageProductChangeLog
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageProductChangeLog
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProductChangeLog
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProductChangeLog
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    fnSku?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    asin?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    status?: ProductStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    tag?: string;
    /**
     * 
     * @type {Array<ProductSupplier>}
     * @memberof Product
     */
    productSuppliers?: Array<ProductSupplier>;
    /**
     * 
     * @type {Group}
     * @memberof Product
     */
    group?: Group;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    fulfilledBy?: string;
    /**
     * 
     * @type {Brand}
     * @memberof Product
     */
    brand?: Brand;
    /**
     * 
     * @type {Brand}
     * @memberof Product
     */
    reBrand?: Brand;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    channel?: ProductChannelEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    longestSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    longestSideDimensionUnit?: ProductLongestSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    medianSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    medianSideDimensionUnit?: ProductMedianSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    shortSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    shortSideDimensionUnit?: ProductShortSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    unitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    unitWeightUnit?: ProductUnitWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    packagingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    packagingWeightUnit?: ProductPackagingWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    shippingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    shippingWeightUnit?: ProductShippingWeightUnitEnum;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Product
     */
    products?: Array<Product>;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    isBundle: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    changedInAmazon?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    amazonFees?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    amazonProductStatus?: ProductAmazonProductStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    changeDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    listingPrice?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    productSizeTier?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    perUnitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    perUnitWeightUnit?: ProductPerUnitWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    landedUnitCost?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    costMargin?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estReferralFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estReferralFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    fbaFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    fbaFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estFeeTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estFeeTotalPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estVariableClosingFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estVariableClosingFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estOrderHandlingFeePerOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estOrderHandlingFeePerOrderPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estPickPackFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estPickPackFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estWeightHandlingFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estWeightHandlingFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    grossProfit?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    grossMarginPercentage?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    session?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    numberOfGoodsOnOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    numberOfGoodsInTransit?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    totalValueOfGoodsOnOrderAndInTransit?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductChannelEnum {
    AmazonUsa = 'AMAZON_USA',
    AmazonUk = 'AMAZON_UK',
    AmazonCa = 'AMAZON_CA',
    AmazonDe = 'AMAZON_DE',
    AmazonMx = 'AMAZON_MX',
    AmazonFr = 'AMAZON_FR',
    AmazonIt = 'AMAZON_IT',
    AmazonEs = 'AMAZON_ES',
    AmazonJp = 'AMAZON_JP',
    AmazonSg = 'AMAZON_SG',
    AmazonAe = 'AMAZON_AE',
    AmazonBr = 'AMAZON_BR',
    AmazonAu = 'AMAZON_AU',
    AmazonIn = 'AMAZON_IN',
    AmazonNl = 'AMAZON_NL',
    AmazonSa = 'AMAZON_SA',
    AmazonTr = 'AMAZON_TR',
    AmazonSe = 'AMAZON_SE',
    AmazonPl = 'AMAZON_PL',
    EtsyUsa = 'ETSY_USA',
    EtsyUk = 'ETSY_UK',
    Wallmart = 'WALLMART',
    Shopify = 'SHOPIFY'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductLongestSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductMedianSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductShortSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductPackagingWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductShippingWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductAmazonProductStatusEnum {
    NoChange = 'NO_CHANGE',
    NewChange = 'NEW_CHANGE',
    Accepted = 'ACCEPTED',
    OnHold = 'ON_HOLD',
    InReview = 'IN_REVIEW'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductPerUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}

/**
 * 
 * @export
 * @interface ProductAcceptRejectDto
 */
export interface ProductAcceptRejectDto {
    /**
     * 
     * @type {Array<number>}
     * @memberof ProductAcceptRejectDto
     */
    productIds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ProductAcceptRejectDto
     */
    action?: string;
}
/**
 * 
 * @export
 * @interface ProductChangeLog
 */
export interface ProductChangeLog {
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    accountId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    productId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    productChangeSource?: ProductChangeLogProductChangeSourceEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    unixDateTimeOfChange?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    dateTimeOfChange?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    marketplace?: ProductChangeLogMarketplaceEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    longestSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    longestSideDimensionUnit?: ProductChangeLogLongestSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    medianSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    medianSideDimensionUnit?: ProductChangeLogMedianSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    shortSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    shortSideDimensionUnit?: ProductChangeLogShortSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    unitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    unitWeightUnit?: ProductChangeLogUnitWeightUnitEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    changeDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    productSizeTier?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    perUnitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductChangeLog
     */
    perUnitWeightUnit?: ProductChangeLogPerUnitWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    estReferralFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    fbaFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductChangeLog
     */
    estFeeTotal?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductChangeLogProductChangeSourceEnum {
    SellervueUser = 'SELLERVUE_USER',
    AmazonProfitPreview = 'AMAZON_PROFIT_PREVIEW',
    CsvImport = 'CSV_IMPORT',
    AmazonImport = 'AMAZON_IMPORT'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductChangeLogMarketplaceEnum {
    AmazonUsa = 'AMAZON_USA',
    AmazonUk = 'AMAZON_UK',
    AmazonCa = 'AMAZON_CA',
    AmazonDe = 'AMAZON_DE',
    AmazonMx = 'AMAZON_MX',
    AmazonFr = 'AMAZON_FR',
    AmazonIt = 'AMAZON_IT',
    AmazonEs = 'AMAZON_ES',
    AmazonJp = 'AMAZON_JP',
    AmazonSg = 'AMAZON_SG',
    AmazonAe = 'AMAZON_AE',
    AmazonBr = 'AMAZON_BR',
    AmazonAu = 'AMAZON_AU',
    AmazonIn = 'AMAZON_IN',
    AmazonNl = 'AMAZON_NL',
    AmazonSa = 'AMAZON_SA',
    AmazonTr = 'AMAZON_TR',
    AmazonSe = 'AMAZON_SE',
    AmazonPl = 'AMAZON_PL',
    EtsyUsa = 'ETSY_USA',
    EtsyUk = 'ETSY_UK',
    Wallmart = 'WALLMART',
    Shopify = 'SHOPIFY'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductChangeLogLongestSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductChangeLogMedianSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductChangeLogShortSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductChangeLogUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductChangeLogPerUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}

/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    fnSku?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    asin?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    status?: ProductDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    tag?: string;
    /**
     * 
     * @type {Array<ProductSupplier>}
     * @memberof ProductDto
     */
    productSuppliers?: Array<ProductSupplier>;
    /**
     * 
     * @type {Group}
     * @memberof ProductDto
     */
    group?: Group;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    fulfilledBy?: string;
    /**
     * 
     * @type {Brand}
     * @memberof ProductDto
     */
    brand?: Brand;
    /**
     * 
     * @type {Brand}
     * @memberof ProductDto
     */
    reBrand?: Brand;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    channel?: ProductDtoChannelEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    longestSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    longestSideDimensionUnit?: ProductDtoLongestSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    medianSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    medianSideDimensionUnit?: ProductDtoMedianSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    shortSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    shortSideDimensionUnit?: ProductDtoShortSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    unitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    unitWeightUnit?: ProductDtoUnitWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    packagingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    packagingWeightUnit?: ProductDtoPackagingWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    shippingWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    shippingWeightUnit?: ProductDtoShippingWeightUnitEnum;
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductDto
     */
    products?: Array<Product>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductDto
     */
    isBundle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductDto
     */
    changedInAmazon?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    amazonFees?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    amazonProductStatus?: ProductDtoAmazonProductStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    changeDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    listingPrice?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    productSizeTier?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    perUnitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    perUnitWeightUnit?: ProductDtoPerUnitWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    landedUnitCost?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    costMargin?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estReferralFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estReferralFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    fbaFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    fbaFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estFeeTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estFeeTotalPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estVariableClosingFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estVariableClosingFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estOrderHandlingFeePerOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estOrderHandlingFeePerOrderPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estPickPackFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estPickPackFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estWeightHandlingFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    estWeightHandlingFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    grossProfit?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    grossMarginPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    numberOfGoodsOnOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    numberOfGoodsInTransit?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    totalValueOfGoodsOnOrderAndInTransit?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    session?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductDtoStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoChannelEnum {
    AmazonUsa = 'AMAZON_USA',
    AmazonUk = 'AMAZON_UK',
    AmazonCa = 'AMAZON_CA',
    AmazonDe = 'AMAZON_DE',
    AmazonMx = 'AMAZON_MX',
    AmazonFr = 'AMAZON_FR',
    AmazonIt = 'AMAZON_IT',
    AmazonEs = 'AMAZON_ES',
    AmazonJp = 'AMAZON_JP',
    AmazonSg = 'AMAZON_SG',
    AmazonAe = 'AMAZON_AE',
    AmazonBr = 'AMAZON_BR',
    AmazonAu = 'AMAZON_AU',
    AmazonIn = 'AMAZON_IN',
    AmazonNl = 'AMAZON_NL',
    AmazonSa = 'AMAZON_SA',
    AmazonTr = 'AMAZON_TR',
    AmazonSe = 'AMAZON_SE',
    AmazonPl = 'AMAZON_PL',
    EtsyUsa = 'ETSY_USA',
    EtsyUk = 'ETSY_UK',
    Wallmart = 'WALLMART',
    Shopify = 'SHOPIFY'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoLongestSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoMedianSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoShortSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoPackagingWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoShippingWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoAmazonProductStatusEnum {
    NoChange = 'NO_CHANGE',
    NewChange = 'NEW_CHANGE',
    Accepted = 'ACCEPTED',
    OnHold = 'ON_HOLD',
    InReview = 'IN_REVIEW'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductDtoPerUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}

/**
 * 
 * @export
 * @interface ProductSupplier
 */
export interface ProductSupplier {
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    countryOfOrigin?: ProductSupplierCountryOfOriginEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    productionLeadTimeInDays?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    inTransitLeadTimeInDays?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    totalLeadTimeInDays?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    supplierTermsInDays?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    shippingMethod?: ProductSupplierShippingMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    material?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    hsCodes?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    tariffRates?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    orderQuantity?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    unitsPerCase?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    totalCases?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    packagingLongestSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    packagingLongestSideDimensionUnit?: ProductSupplierPackagingLongestSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    packagingMedianSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    packagingMedianSideDimensionUnit?: ProductSupplierPackagingMedianSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    packagingShortSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    packagingShortSideDimensionUnit?: ProductSupplierPackagingShortSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    packagingUnitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    packagingUnitWeightUnit?: ProductSupplierPackagingUnitWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    caseLongestSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    caseLongestSideDimensionUnit?: ProductSupplierCaseLongestSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    caseMedianSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    caseMedianSideDimensionUnit?: ProductSupplierCaseMedianSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    caseShortSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    caseShortSideDimensionUnit?: ProductSupplierCaseShortSideDimensionUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    caseGrossWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    caseGrossWeightUnit?: ProductSupplierCaseGrossWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    cubicMetres?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    totalGrossWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductSupplier
     */
    totalGrossWeightUnit?: ProductSupplierTotalGrossWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    id?: number;
    /**
     * 
     * @type {Product}
     * @memberof ProductSupplier
     */
    product?: Product;
    /**
     * 
     * @type {Supplier}
     * @memberof ProductSupplier
     */
    supplier?: Supplier;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    accountId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductSupplier
     */
    leadTime?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierCountryOfOriginEnum {
    Us = 'US',
    Ca = 'CA',
    Gb = 'GB',
    Cn = 'CN',
    Mx = 'MX',
    Af = 'AF',
    Ax = 'AX',
    Al = 'AL',
    Dz = 'DZ',
    As = 'AS',
    Ad = 'AD',
    Ao = 'AO',
    Ai = 'AI',
    Aq = 'AQ',
    Ag = 'AG',
    Ar = 'AR',
    Am = 'AM',
    Aw = 'AW',
    Au = 'AU',
    At = 'AT',
    Az = 'AZ',
    Bs = 'BS',
    Bh = 'BH',
    Bd = 'BD',
    Bb = 'BB',
    By = 'BY',
    Be = 'BE',
    Bz = 'BZ',
    Bj = 'BJ',
    Bm = 'BM',
    Bt = 'BT',
    Bo = 'BO',
    Bq = 'BQ',
    Ba = 'BA',
    Bw = 'BW',
    Bv = 'BV',
    Br = 'BR',
    Io = 'IO',
    Bn = 'BN',
    Bg = 'BG',
    Bf = 'BF',
    Bi = 'BI',
    Cv = 'CV',
    Kh = 'KH',
    Cm = 'CM',
    Ky = 'KY',
    Cf = 'CF',
    Td = 'TD',
    Cl = 'CL',
    Cx = 'CX',
    Cc = 'CC',
    Co = 'CO',
    Km = 'KM',
    Cg = 'CG',
    Cd = 'CD',
    Ck = 'CK',
    Cr = 'CR',
    Ci = 'CI',
    Hr = 'HR',
    Cu = 'CU',
    Cw = 'CW',
    Cy = 'CY',
    Cz = 'CZ',
    Dk = 'DK',
    Dj = 'DJ',
    Dm = 'DM',
    Do = 'DO',
    Ec = 'EC',
    Eg = 'EG',
    Sv = 'SV',
    Gq = 'GQ',
    Er = 'ER',
    Ee = 'EE',
    Sz = 'SZ',
    Et = 'ET',
    Fk = 'FK',
    Fo = 'FO',
    Fj = 'FJ',
    Fi = 'FI',
    Fr = 'FR',
    Gf = 'GF',
    Pf = 'PF',
    Tf = 'TF',
    Ga = 'GA',
    Gm = 'GM',
    Ge = 'GE',
    De = 'DE',
    Gh = 'GH',
    Gi = 'GI',
    Gr = 'GR',
    Gl = 'GL',
    Gd = 'GD',
    Gp = 'GP',
    Gu = 'GU',
    Gt = 'GT',
    Gg = 'GG',
    Gn = 'GN',
    Gw = 'GW',
    Gy = 'GY',
    Ht = 'HT',
    Hm = 'HM',
    Va = 'VA',
    Hn = 'HN',
    Hk = 'HK',
    Hu = 'HU',
    Is = 'IS',
    In = 'IN',
    Id = 'ID',
    Ir = 'IR',
    Iq = 'IQ',
    Ie = 'IE',
    Im = 'IM',
    Il = 'IL',
    It = 'IT',
    Jm = 'JM',
    Jp = 'JP',
    Je = 'JE',
    Jo = 'JO',
    Kz = 'KZ',
    Ke = 'KE',
    Ki = 'KI',
    Kp = 'KP',
    Kr = 'KR',
    Kw = 'KW',
    Kg = 'KG',
    La = 'LA',
    Lv = 'LV',
    Lb = 'LB',
    Ls = 'LS',
    Lr = 'LR',
    Ly = 'LY',
    Li = 'LI',
    Lt = 'LT',
    Lu = 'LU',
    Mo = 'MO',
    Mg = 'MG',
    Mw = 'MW',
    My = 'MY',
    Mv = 'MV',
    Ml = 'ML',
    Mt = 'MT',
    Mh = 'MH',
    Mq = 'MQ',
    Mr = 'MR',
    Mu = 'MU',
    Yt = 'YT',
    Fm = 'FM',
    Md = 'MD',
    Mc = 'MC',
    Mn = 'MN',
    Me = 'ME',
    Ms = 'MS',
    Ma = 'MA',
    Mz = 'MZ',
    Mm = 'MM',
    Na = 'NA',
    Nr = 'NR',
    Np = 'NP',
    Nl = 'NL',
    Nc = 'NC',
    Nz = 'NZ',
    Ni = 'NI',
    Ne = 'NE',
    Ng = 'NG',
    Nu = 'NU',
    Nf = 'NF',
    Mk = 'MK',
    Mp = 'MP',
    No = 'NO',
    Om = 'OM',
    Pk = 'PK',
    Pw = 'PW',
    Ps = 'PS',
    Pa = 'PA',
    Pg = 'PG',
    Py = 'PY',
    Pe = 'PE',
    Ph = 'PH',
    Pn = 'PN',
    Pl = 'PL',
    Pt = 'PT',
    Pr = 'PR',
    Qa = 'QA',
    Re = 'RE',
    Ro = 'RO',
    Ru = 'RU',
    Rw = 'RW',
    Bl = 'BL',
    Sh = 'SH',
    Kn = 'KN',
    Lc = 'LC',
    Mf = 'MF',
    Pm = 'PM',
    Vc = 'VC',
    Ws = 'WS',
    Sm = 'SM',
    St = 'ST',
    Sa = 'SA',
    Sn = 'SN',
    Rs = 'RS',
    Sc = 'SC',
    Sl = 'SL',
    Sg = 'SG',
    Sx = 'SX',
    Sk = 'SK',
    Si = 'SI',
    Sb = 'SB',
    So = 'SO',
    Za = 'ZA',
    Gs = 'GS',
    Ss = 'SS',
    Es = 'ES',
    Lk = 'LK',
    Sd = 'SD',
    Sr = 'SR',
    Sj = 'SJ',
    Se = 'SE',
    Ch = 'CH',
    Sy = 'SY',
    Tw = 'TW',
    Tj = 'TJ',
    Tz = 'TZ',
    Th = 'TH',
    Tl = 'TL',
    Tg = 'TG',
    Tk = 'TK',
    To = 'TO',
    Tt = 'TT',
    Tn = 'TN',
    Tr = 'TR',
    Tm = 'TM',
    Tc = 'TC',
    Tv = 'TV',
    Ug = 'UG',
    Ua = 'UA',
    Ae = 'AE',
    Um = 'UM',
    Uy = 'UY',
    Uz = 'UZ',
    Vu = 'VU',
    Ve = 'VE',
    Vn = 'VN',
    Vg = 'VG',
    Vi = 'VI',
    Wf = 'WF',
    Eh = 'EH',
    Ye = 'YE',
    Zm = 'ZM',
    Zw = 'ZW'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierShippingMethodEnum {
    Air = 'AIR',
    Sea = 'SEA',
    Land = 'LAND'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierPackagingLongestSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierPackagingMedianSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierPackagingShortSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierPackagingUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierCaseLongestSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierCaseMedianSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierCaseShortSideDimensionUnitEnum {
    Cm = 'CM',
    In = 'IN',
    Mm = 'MM'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierCaseGrossWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductSupplierTotalGrossWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}

/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    open?: boolean;
    /**
     * 
     * @type {any}
     * @memberof Resource
     */
    file?: any;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    readable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    filename?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof Resource
     */
    inputStream?: object;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Supplier
 */
export interface Supplier {
    /**
     * 
     * @type {number}
     * @memberof Supplier
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    telephoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Supplier
     */
    companyName?: string;
    /**
     * 
     * @type {number}
     * @memberof Supplier
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof Supplier
     */
    accountId?: number;
}

/**
 * BrandControllerApi - axios parameter creator
 * @export
 */
export const BrandControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {BrandDto} [brandDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrand: async (userId: number, brandDto?: BrandDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createBrand', 'userId', userId)
            const localVarPath = `/brands/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(brandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBrand: async (userId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteBrand', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBrand', 'id', id)
            const localVarPath = `/brands/{userId}/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBrands: async (pageable: Pageable, userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllBrands', 'pageable', pageable)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllBrands', 'userId', userId)
            const localVarPath = `/brands/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandById: async (userId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getBrandById', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBrandById', 'id', id)
            const localVarPath = `/brands/{userId}/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {BrandDto} [brandDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceBrand: async (userId: number, id: number, brandDto?: BrandDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('replaceBrand', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceBrand', 'id', id)
            const localVarPath = `/brands/{userId}/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(brandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandControllerApi - functional programming interface
 * @export
 */
export const BrandControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {BrandDto} [brandDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrand(userId: number, brandDto?: BrandDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrand(userId, brandDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBrand(userId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: boolean; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBrand(userId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBrands(pageable: Pageable, userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageBrand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBrands(pageable, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandById(userId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBrandById(userId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {BrandDto} [brandDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceBrand(userId: number, id: number, brandDto?: BrandDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceBrand(userId, id, brandDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BrandControllerApi - factory interface
 * @export
 */
export const BrandControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {BrandDto} [brandDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrand(userId: number, brandDto?: BrandDto, options?: any): AxiosPromise<Brand> {
            return localVarFp.createBrand(userId, brandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBrand(userId: number, id: number, options?: any): AxiosPromise<{ [key: string]: boolean; }> {
            return localVarFp.deleteBrand(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBrands(pageable: Pageable, userId: number, options?: any): AxiosPromise<PageBrand> {
            return localVarFp.getAllBrands(pageable, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandById(userId: number, id: number, options?: any): AxiosPromise<Brand> {
            return localVarFp.getBrandById(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {BrandDto} [brandDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceBrand(userId: number, id: number, brandDto?: BrandDto, options?: any): AxiosPromise<Brand> {
            return localVarFp.replaceBrand(userId, id, brandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandControllerApi - object-oriented interface
 * @export
 * @class BrandControllerApi
 * @extends {BaseAPI}
 */
export class BrandControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {BrandDto} [brandDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandControllerApi
     */
    public createBrand(userId: number, brandDto?: BrandDto, options?: any) {
        return BrandControllerApiFp(this.configuration).createBrand(userId, brandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandControllerApi
     */
    public deleteBrand(userId: number, id: number, options?: any) {
        return BrandControllerApiFp(this.configuration).deleteBrand(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandControllerApi
     */
    public getAllBrands(pageable: Pageable, userId: number, options?: any) {
        return BrandControllerApiFp(this.configuration).getAllBrands(pageable, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandControllerApi
     */
    public getBrandById(userId: number, id: number, options?: any) {
        return BrandControllerApiFp(this.configuration).getBrandById(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {BrandDto} [brandDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandControllerApi
     */
    public replaceBrand(userId: number, id: number, brandDto?: BrandDto, options?: any) {
        return BrandControllerApiFp(this.configuration).replaceBrand(userId, id, brandDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CsvControllerApi - axios parameter creator
 * @export
 */
export const CsvControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importProductCsv: async (userId: number, inlineObject1?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('importProductCsv', 'userId', userId)
            const localVarPath = `/products/{userId}/csv`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCsvTemplate: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveCsvTemplate', 'userId', userId)
            const localVarPath = `/products/{userId}/csv-template`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CsvControllerApi - functional programming interface
 * @export
 */
export const CsvControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CsvControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importProductCsv(userId: number, inlineObject1?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importProductCsv(userId, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCsvTemplate(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCsvTemplate(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CsvControllerApi - factory interface
 * @export
 */
export const CsvControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CsvControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importProductCsv(userId: number, inlineObject1?: InlineObject1, options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.importProductCsv(userId, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCsvTemplate(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrieveCsvTemplate(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CsvControllerApi - object-oriented interface
 * @export
 * @class CsvControllerApi
 * @extends {BaseAPI}
 */
export class CsvControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CsvControllerApi
     */
    public importProductCsv(userId: number, inlineObject1?: InlineObject1, options?: any) {
        return CsvControllerApiFp(this.configuration).importProductCsv(userId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CsvControllerApi
     */
    public retrieveCsvTemplate(userId: number, options?: any) {
        return CsvControllerApiFp(this.configuration).retrieveCsvTemplate(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeasurementUnitsControllerApi - axios parameter creator
 * @export
 */
export const MeasurementUnitsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDimensionUnits: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllDimensionUnits', 'userId', userId)
            const localVarPath = `/products/{userId}/dimension-units`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWeightUnits: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllWeightUnits', 'userId', userId)
            const localVarPath = `/products/{userId}/weight-units`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeasurementUnitsControllerApi - functional programming interface
 * @export
 */
export const MeasurementUnitsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeasurementUnitsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDimensionUnits(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDimensionUnits(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWeightUnits(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWeightUnits(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeasurementUnitsControllerApi - factory interface
 * @export
 */
export const MeasurementUnitsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeasurementUnitsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDimensionUnits(userId: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getAllDimensionUnits(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWeightUnits(userId: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getAllWeightUnits(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeasurementUnitsControllerApi - object-oriented interface
 * @export
 * @class MeasurementUnitsControllerApi
 * @extends {BaseAPI}
 */
export class MeasurementUnitsControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementUnitsControllerApi
     */
    public getAllDimensionUnits(userId: number, options?: any) {
        return MeasurementUnitsControllerApiFp(this.configuration).getAllDimensionUnits(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementUnitsControllerApi
     */
    public getAllWeightUnits(userId: number, options?: any) {
        return MeasurementUnitsControllerApiFp(this.configuration).getAllWeightUnits(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductAdminControllerApi - axios parameter creator
 * @export
 */
export const ProductAdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSerialisedProductDataForAccount: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('downloadSerialisedProductDataForAccount', 'userId', userId)
            const localVarPath = `/admin/products/{userId}/vending`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixSupplierNamesAfterImportForUser: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('fixSupplierNamesAfterImportForUser', 'userId', userId)
            const localVarPath = `/admin/products/{userId}/vending/fix-names`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAllProducts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/products/sync/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncProductsByUser: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('syncProductsByUser', 'userId', userId)
            const localVarPath = `/admin/products/{userId}/sync`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSerialisedProductDataForAccount: async (userId: number, inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('uploadSerialisedProductDataForAccount', 'userId', userId)
            const localVarPath = `/admin/products/{userId}/vending`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductAdminControllerApi - functional programming interface
 * @export
 */
export const ProductAdminControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductAdminControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSerialisedProductDataForAccount(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSerialisedProductDataForAccount(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fixSupplierNamesAfterImportForUser(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: boolean; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fixSupplierNamesAfterImportForUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncAllProducts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: boolean; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncAllProducts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncProductsByUser(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: boolean; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncProductsByUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSerialisedProductDataForAccount(userId: number, inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSerialisedProductDataForAccount(userId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductAdminControllerApi - factory interface
 * @export
 */
export const ProductAdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductAdminControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSerialisedProductDataForAccount(userId: number, options?: any): AxiosPromise<Resource> {
            return localVarFp.downloadSerialisedProductDataForAccount(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixSupplierNamesAfterImportForUser(userId: number, options?: any): AxiosPromise<{ [key: string]: boolean; }> {
            return localVarFp.fixSupplierNamesAfterImportForUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAllProducts(options?: any): AxiosPromise<{ [key: string]: boolean; }> {
            return localVarFp.syncAllProducts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncProductsByUser(userId: number, options?: any): AxiosPromise<{ [key: string]: boolean; }> {
            return localVarFp.syncProductsByUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSerialisedProductDataForAccount(userId: number, inlineObject?: InlineObject, options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.uploadSerialisedProductDataForAccount(userId, inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductAdminControllerApi - object-oriented interface
 * @export
 * @class ProductAdminControllerApi
 * @extends {BaseAPI}
 */
export class ProductAdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductAdminControllerApi
     */
    public downloadSerialisedProductDataForAccount(userId: number, options?: any) {
        return ProductAdminControllerApiFp(this.configuration).downloadSerialisedProductDataForAccount(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductAdminControllerApi
     */
    public fixSupplierNamesAfterImportForUser(userId: number, options?: any) {
        return ProductAdminControllerApiFp(this.configuration).fixSupplierNamesAfterImportForUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductAdminControllerApi
     */
    public syncAllProducts(options?: any) {
        return ProductAdminControllerApiFp(this.configuration).syncAllProducts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductAdminControllerApi
     */
    public syncProductsByUser(userId: number, options?: any) {
        return ProductAdminControllerApiFp(this.configuration).syncProductsByUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductAdminControllerApi
     */
    public uploadSerialisedProductDataForAccount(userId: number, inlineObject?: InlineObject, options?: any) {
        return ProductAdminControllerApiFp(this.configuration).uploadSerialisedProductDataForAccount(userId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductControllerApi - axios parameter creator
 * @export
 */
export const ProductControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {ProductAcceptRejectDto} [productAcceptRejectDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRejectAmazonChanges: async (userId: number, productAcceptRejectDto?: ProductAcceptRejectDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('acceptRejectAmazonChanges', 'userId', userId)
            const localVarPath = `/products/{userId}/accept-reject`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productAcceptRejectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {ProductDto} [productDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (userId: number, productDto?: ProductDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createProduct', 'userId', userId)
            const localVarPath = `/products/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (userId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteProduct', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/products/{userId}/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchProductChangeLogSources: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('fetchProductChangeLogSources', 'userId', userId)
            const localVarPath = `/products/{userId}/changelog-sources`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchProductChangeLogsForProduct: async (userId: number, productId: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('fetchProductChangeLogsForProduct', 'userId', userId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('fetchProductChangeLogsForProduct', 'productId', productId)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('fetchProductChangeLogsForProduct', 'pageable', pageable)
            const localVarPath = `/products/{userId}/{productId}/changelog`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {number} userId 
         * @param {string} [sku] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (pageable: Pageable, userId: number, sku?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllProducts', 'pageable', pageable)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllProducts', 'userId', userId)
            const localVarPath = `/products/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (sku !== undefined) {
                localVarQueryParameter['sku'] = sku;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShippingMethods: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllShippingMethods', 'userId', userId)
            const localVarPath = `/products/{userId}/shipping-methods`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById: async (userId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProductById', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductById', 'id', id)
            const localVarPath = `/products/{userId}/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCountryOfOriginOptions: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProductCountryOfOriginOptions', 'userId', userId)
            const localVarPath = `/products/{userId}/countries`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ProductDto} [productDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceProduct: async (userId: number, id: number, productDto?: ProductDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('replaceProduct', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceProduct', 'id', id)
            const localVarPath = `/products/{userId}/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {NotificationDto} [notificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification: async (userId: number, notificationDto?: NotificationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendNotification', 'userId', userId)
            const localVarPath = `/products/{userId}/notification`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductControllerApi - functional programming interface
 * @export
 */
export const ProductControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {ProductAcceptRejectDto} [productAcceptRejectDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptRejectAmazonChanges(userId: number, productAcceptRejectDto?: ProductAcceptRejectDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptRejectAmazonChanges(userId, productAcceptRejectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {ProductDto} [productDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(userId: number, productDto?: ProductDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(userId, productDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(userId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: boolean; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(userId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchProductChangeLogSources(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchProductChangeLogSources(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchProductChangeLogsForProduct(userId: number, productId: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageProductChangeLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchProductChangeLogsForProduct(userId, productId, pageable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {number} userId 
         * @param {string} [sku] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(pageable: Pageable, userId: number, sku?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(pageable, userId, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllShippingMethods(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllShippingMethods(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductById(userId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductById(userId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductCountryOfOriginOptions(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductCountryOfOriginOptions(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ProductDto} [productDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceProduct(userId: number, id: number, productDto?: ProductDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceProduct(userId, id, productDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {NotificationDto} [notificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendNotification(userId: number, notificationDto?: NotificationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendNotification(userId, notificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductControllerApi - factory interface
 * @export
 */
export const ProductControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {ProductAcceptRejectDto} [productAcceptRejectDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRejectAmazonChanges(userId: number, productAcceptRejectDto?: ProductAcceptRejectDto, options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.acceptRejectAmazonChanges(userId, productAcceptRejectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {ProductDto} [productDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(userId: number, productDto?: ProductDto, options?: any): AxiosPromise<Product> {
            return localVarFp.createProduct(userId, productDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(userId: number, id: number, options?: any): AxiosPromise<{ [key: string]: boolean; }> {
            return localVarFp.deleteProduct(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchProductChangeLogSources(userId: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.fetchProductChangeLogSources(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchProductChangeLogsForProduct(userId: number, productId: number, pageable: Pageable, options?: any): AxiosPromise<PageProductChangeLog> {
            return localVarFp.fetchProductChangeLogsForProduct(userId, productId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {number} userId 
         * @param {string} [sku] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(pageable: Pageable, userId: number, sku?: string, options?: any): AxiosPromise<PageProduct> {
            return localVarFp.getAllProducts(pageable, userId, sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShippingMethods(userId: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getAllShippingMethods(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById(userId: number, id: number, options?: any): AxiosPromise<Product> {
            return localVarFp.getProductById(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCountryOfOriginOptions(userId: string, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getProductCountryOfOriginOptions(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} id 
         * @param {ProductDto} [productDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceProduct(userId: number, id: number, productDto?: ProductDto, options?: any): AxiosPromise<Product> {
            return localVarFp.replaceProduct(userId, id, productDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {NotificationDto} [notificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification(userId: number, notificationDto?: NotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.sendNotification(userId, notificationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductControllerApi - object-oriented interface
 * @export
 * @class ProductControllerApi
 * @extends {BaseAPI}
 */
export class ProductControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {ProductAcceptRejectDto} [productAcceptRejectDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public acceptRejectAmazonChanges(userId: number, productAcceptRejectDto?: ProductAcceptRejectDto, options?: any) {
        return ProductControllerApiFp(this.configuration).acceptRejectAmazonChanges(userId, productAcceptRejectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {ProductDto} [productDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public createProduct(userId: number, productDto?: ProductDto, options?: any) {
        return ProductControllerApiFp(this.configuration).createProduct(userId, productDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public deleteProduct(userId: number, id: number, options?: any) {
        return ProductControllerApiFp(this.configuration).deleteProduct(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public fetchProductChangeLogSources(userId: number, options?: any) {
        return ProductControllerApiFp(this.configuration).fetchProductChangeLogSources(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} productId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public fetchProductChangeLogsForProduct(userId: number, productId: number, pageable: Pageable, options?: any) {
        return ProductControllerApiFp(this.configuration).fetchProductChangeLogsForProduct(userId, productId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {number} userId 
     * @param {string} [sku] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public getAllProducts(pageable: Pageable, userId: number, sku?: string, options?: any) {
        return ProductControllerApiFp(this.configuration).getAllProducts(pageable, userId, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public getAllShippingMethods(userId: number, options?: any) {
        return ProductControllerApiFp(this.configuration).getAllShippingMethods(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public getProductById(userId: number, id: number, options?: any) {
        return ProductControllerApiFp(this.configuration).getProductById(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public getProductCountryOfOriginOptions(userId: string, options?: any) {
        return ProductControllerApiFp(this.configuration).getProductCountryOfOriginOptions(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} id 
     * @param {ProductDto} [productDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public replaceProduct(userId: number, id: number, productDto?: ProductDto, options?: any) {
        return ProductControllerApiFp(this.configuration).replaceProduct(userId, id, productDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {NotificationDto} [notificationDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public sendNotification(userId: number, notificationDto?: NotificationDto, options?: any) {
        return ProductControllerApiFp(this.configuration).sendNotification(userId, notificationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


