/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CostsWithStats
 */
export interface CostsWithStats {
    /**
     * 
     * @type {PageLineCost}
     * @memberof CostsWithStats
     */
    lineCosts?: PageLineCost;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    accountId?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    costEntryCount?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    totalUnitsOrdered?: number;
    /**
     * 
     * @type {string}
     * @memberof CostsWithStats
     */
    lastCostUpdateDate?: string;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    unixLastCostUpdateDate?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    totalFactoryCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    totalInboundCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    totalLandedCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    totalFactoryUnitCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    totalInboundUnitCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof CostsWithStats
     */
    totalLandedUnitCosts?: number;
    /**
     * 
     * @type {Product}
     * @memberof CostsWithStats
     */
    product?: Product;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    unixDate?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    payReferenceNumber?: string;
    /**
     * 
     * @type {Array<InvoiceLine>}
     * @memberof Invoice
     */
    invoiceLines?: Array<InvoiceLine>;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    accountId?: number;
}
/**
 * 
 * @export
 * @interface InvoiceLine
 */
export interface InvoiceLine {
    /**
     * 
     * @type {number}
     * @memberof InvoiceLine
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLine
     */
    internalReference?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceLine
     */
    costType?: InvoiceLineCostTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLine
     */
    quantity?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLine
     */
    perUnitCost?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLine
     */
    amount?: number;
    /**
     * 
     * @type {Product}
     * @memberof InvoiceLine
     */
    product?: Product;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLine
     */
    isExcludedFromProductCostsData?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceLine
     */
    isExcludedFromGeneralCostsData?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLine
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceLine
     */
    accountId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoiceLineCostTypeEnum {
    Shipping = 'SHIPPING',
    FactoryInvoice = 'FACTORY_INVOICE',
    CustomsAndDuties = 'CUSTOMS_AND_DUTIES',
    Inspections = 'INSPECTIONS',
    LocalFreight = 'LOCAL_FREIGHT',
    Photography = 'PHOTOGRAPHY',
    DesignerFees = 'DESIGNER_FEES',
    ProductSamples = 'PRODUCT_SAMPLES',
    ProductTesting = 'PRODUCT_TESTING',
    Storage = 'STORAGE',
    Insurance = 'INSURANCE',
    BankFees = 'BANK_FEES',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface LineCost
 */
export interface LineCost {
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof LineCost
     */
    internalReference?: string;
    /**
     * 
     * @type {Product}
     * @memberof LineCost
     */
    product?: Product;
    /**
     * 
     * @type {Invoice}
     * @memberof LineCost
     */
    invoice?: Invoice;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    factoryUnits?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    factoryCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    inboundCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    totalCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    quantityOrdered?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LineCost
     */
    isExcludedFromProductCostsData?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LineCost
     */
    isExcludedFromGeneralCostsData?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof LineCost
     */
    costType?: LineCostCostTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof LineCost
     */
    invoiceLineId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum LineCostCostTypeEnum {
    Shipping = 'SHIPPING',
    FactoryInvoice = 'FACTORY_INVOICE',
    CustomsAndDuties = 'CUSTOMS_AND_DUTIES',
    Inspections = 'INSPECTIONS',
    LocalFreight = 'LOCAL_FREIGHT',
    Photography = 'PHOTOGRAPHY',
    DesignerFees = 'DESIGNER_FEES',
    ProductSamples = 'PRODUCT_SAMPLES',
    ProductTesting = 'PRODUCT_TESTING',
    Storage = 'STORAGE',
    Insurance = 'INSURANCE',
    BankFees = 'BANK_FEES',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface LineCostList
 */
export interface LineCostList {
    /**
     * 
     * @type {PageLineCost}
     * @memberof LineCostList
     */
    lineCosts?: PageLineCost;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    accountId?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    totalUnitsOrdered?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    totalFactoryCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    totalInboundCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    totalLandedCosts?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    averageCost?: number;
    /**
     * 
     * @type {number}
     * @memberof LineCostList
     */
    costEntryCount?: number;
}
/**
 * 
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * 
     * @type {number}
     * @memberof NotificationDto
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationDto
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationDto
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    notificationStatus?: NotificationDtoNotificationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    notificationType?: NotificationDtoNotificationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    notificationSource?: NotificationDtoNotificationSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    entityType?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    messageDateTime?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationDtoNotificationStatusEnum {
    Unread = 'UNREAD',
    Read = 'READ',
    Dismissed = 'DISMISSED'
}
/**
    * @export
    * @enum {string}
    */
export enum NotificationDtoNotificationTypeEnum {
    Info = 'INFO',
    ActionNeeded = 'ACTION_NEEDED',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum NotificationDtoNotificationSourceEnum {
    GatewayService = 'GATEWAY_SERVICE',
    InvoiceService = 'INVOICE_SERVICE',
    NotificationService = 'NOTIFICATION_SERVICE',
    ProductService = 'PRODUCT_SERVICE',
    ReportingService = 'REPORTING_SERVICE',
    SchedulerService = 'SCHEDULER_SERVICE',
    SupplierService = 'SUPPLIER_SERVICE',
    ShopifyService = 'SHOPIFY_SERVICE',
    AmazonService = 'AMAZON_SERVICE',
    UserService = 'USER_SERVICE',
    XeroService = 'XERO_SERVICE',
    OrdersService = 'ORDERS_SERVICE'
}

/**
 * 
 * @export
 * @interface PageLineCost
 */
export interface PageLineCost {
    /**
     * 
     * @type {number}
     * @memberof PageLineCost
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageLineCost
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageLineCost
     */
    size?: number;
    /**
     * 
     * @type {Array<LineCost>}
     * @memberof PageLineCost
     */
    content?: Array<LineCost>;
    /**
     * 
     * @type {number}
     * @memberof PageLineCost
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageLineCost
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageLineCost
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageLineCost
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageLineCost
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageLineCost
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageLineCost
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageMap
 */
export interface PageMap {
    /**
     * 
     * @type {number}
     * @memberof PageMap
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMap
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMap
     */
    size?: number;
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof PageMap
     */
    content?: Array<{ [key: string]: object; }>;
    /**
     * 
     * @type {number}
     * @memberof PageMap
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageMap
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageMap
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageMap
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageMap
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageMap
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageMap
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageProduct
 */
export interface PageProduct {
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    size?: number;
    /**
     * 
     * @type {Array<Product>}
     * @memberof PageProduct
     */
    content?: Array<Product>;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageProduct
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageProduct
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageProduct
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageProduct
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProduct
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProduct
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    asin?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    fnSku?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    status?: ProductStatusEnum;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Product
     */
    products?: Array<Product>;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    isBundle?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    longestSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    longestSideDimensionUnit?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    medianSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    medianSideDimensionUnit?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    shortSideDimension?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    shortSideDimensionUnit?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    dimensionUnit?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    currency?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    changedInAmazon?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    amazonFees?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    amazonProductStatus?: ProductAmazonProductStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    changeDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    listingPrice?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    productSizeTier?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    perUnitWeight?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    perUnitWeightUnit?: ProductPerUnitWeightUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    landedUnitCost?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    costMargin?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estReferralFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estReferralFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    fbaFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    fbaFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estFeeTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estFeeTotalPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estVariableClosingFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estVariableClosingFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estOrderHandlingFeePerOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estOrderHandlingFeePerOrderPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estPickPackFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estPickPackFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estWeightHandlingFee?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    estWeightHandlingFeePercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    grossProfit?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    grossMarginPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    numberOfGoodsOnOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    numberOfGoodsInTransit?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    totalValueOfGoodsOnOrderAndInTransit?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductStatusEnum {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductAmazonProductStatusEnum {
    NoChange = 'NO_CHANGE',
    NewChange = 'NEW_CHANGE',
    Accepted = 'ACCEPTED',
    OnHold = 'ON_HOLD',
    InReview = 'IN_REVIEW'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductPerUnitWeightUnitEnum {
    Gr = 'GR',
    Oz = 'OZ',
    Lb = 'LB',
    Kg = 'KG'
}

/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}

/**
 * ReportingControllerApi - axios parameter creator
 * @export
 */
export const ReportingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {boolean} [changedInAmazon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAmazonProductsByUserId: async (userId: number, pageable: Pageable, changedInAmazon?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllAmazonProductsByUserId', 'userId', userId)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllAmazonProductsByUserId', 'pageable', pageable)
            const localVarPath = `/reporting/{userId}/amazon-products`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (changedInAmazon !== undefined) {
                localVarQueryParameter['changedInAmazon'] = changedInAmazon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductStatsByUserId: async (userId: number, pageable: Pageable, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllProductStatsByUserId', 'userId', userId)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllProductStatsByUserId', 'pageable', pageable)
            const localVarPath = `/reporting/{userId}/products`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsedCostTypesByUserId: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllUsedCostTypesByUserId', 'userId', userId)
            const localVarPath = `/reporting/{userId}/cost-types`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostsByProductId: async (userId: number, productId: number, pageable: Pageable, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getCostsByProductId', 'userId', userId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getCostsByProductId', 'productId', productId)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getCostsByProductId', 'pageable', pageable)
            const localVarPath = `/reporting/{userId}/costs/{productId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostsByUserId: async (userId: number, pageable: Pageable, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getCostsByUserId', 'userId', userId)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getCostsByUserId', 'pageable', pageable)
            const localVarPath = `/reporting/{userId}/costs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductStatsById: async (userId: number, productId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProductStatsById', 'userId', userId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductStatsById', 'productId', productId)
            const localVarPath = `/reporting/{userId}/products/{productId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {NotificationDto} [notificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification: async (userId: number, notificationDto?: NotificationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendNotification', 'userId', userId)
            const localVarPath = `/reporting/{userId}/notification`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportingControllerApi - functional programming interface
 * @export
 */
export const ReportingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {boolean} [changedInAmazon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAmazonProductsByUserId(userId: number, pageable: Pageable, changedInAmazon?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAmazonProductsByUserId(userId, pageable, changedInAmazon, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProductStatsByUserId(userId: number, pageable: Pageable, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProductStatsByUserId(userId, pageable, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsedCostTypesByUserId(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsedCostTypesByUserId(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCostsByProductId(userId: number, productId: number, pageable: Pageable, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostsWithStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCostsByProductId(userId, productId, pageable, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCostsByUserId(userId: number, pageable: Pageable, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LineCostList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCostsByUserId(userId, pageable, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductStatsById(userId: number, productId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductStatsById(userId, productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {NotificationDto} [notificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendNotification(userId: number, notificationDto?: NotificationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendNotification(userId, notificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportingControllerApi - factory interface
 * @export
 */
export const ReportingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {boolean} [changedInAmazon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAmazonProductsByUserId(userId: number, pageable: Pageable, changedInAmazon?: boolean, options?: any): AxiosPromise<PageProduct> {
            return localVarFp.getAllAmazonProductsByUserId(userId, pageable, changedInAmazon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductStatsByUserId(userId: number, pageable: Pageable, search?: string, options?: any): AxiosPromise<PageMap> {
            return localVarFp.getAllProductStatsByUserId(userId, pageable, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsedCostTypesByUserId(userId: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getAllUsedCostTypesByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostsByProductId(userId: number, productId: number, pageable: Pageable, search?: string, options?: any): AxiosPromise<CostsWithStats> {
            return localVarFp.getCostsByProductId(userId, productId, pageable, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {Pageable} pageable 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostsByUserId(userId: number, pageable: Pageable, search?: string, options?: any): AxiosPromise<LineCostList> {
            return localVarFp.getCostsByUserId(userId, pageable, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductStatsById(userId: number, productId: number, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getProductStatsById(userId, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {NotificationDto} [notificationDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendNotification(userId: number, notificationDto?: NotificationDto, options?: any): AxiosPromise<NotificationDto> {
            return localVarFp.sendNotification(userId, notificationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportingControllerApi - object-oriented interface
 * @export
 * @class ReportingControllerApi
 * @extends {BaseAPI}
 */
export class ReportingControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {Pageable} pageable 
     * @param {boolean} [changedInAmazon] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingControllerApi
     */
    public getAllAmazonProductsByUserId(userId: number, pageable: Pageable, changedInAmazon?: boolean, options?: any) {
        return ReportingControllerApiFp(this.configuration).getAllAmazonProductsByUserId(userId, pageable, changedInAmazon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {Pageable} pageable 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingControllerApi
     */
    public getAllProductStatsByUserId(userId: number, pageable: Pageable, search?: string, options?: any) {
        return ReportingControllerApiFp(this.configuration).getAllProductStatsByUserId(userId, pageable, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingControllerApi
     */
    public getAllUsedCostTypesByUserId(userId: number, options?: any) {
        return ReportingControllerApiFp(this.configuration).getAllUsedCostTypesByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} productId 
     * @param {Pageable} pageable 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingControllerApi
     */
    public getCostsByProductId(userId: number, productId: number, pageable: Pageable, search?: string, options?: any) {
        return ReportingControllerApiFp(this.configuration).getCostsByProductId(userId, productId, pageable, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {Pageable} pageable 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingControllerApi
     */
    public getCostsByUserId(userId: number, pageable: Pageable, search?: string, options?: any) {
        return ReportingControllerApiFp(this.configuration).getCostsByUserId(userId, pageable, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingControllerApi
     */
    public getProductStatsById(userId: number, productId: number, options?: any) {
        return ReportingControllerApiFp(this.configuration).getProductStatsById(userId, productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {NotificationDto} [notificationDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingControllerApi
     */
    public sendNotification(userId: number, notificationDto?: NotificationDto, options?: any) {
        return ReportingControllerApiFp(this.configuration).sendNotification(userId, notificationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


